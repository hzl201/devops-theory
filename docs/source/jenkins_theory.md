# 持续部署理论
> 以前写前端项目打包部署，都是手动运行命令，打包完，然后压缩，再上传到服务器解压。这种方式确实有点low并且效率也不高。
> 自从用了Jenkins持续集成工具，写前端项目越来越工程化，再也不用担心忘记部署项目，也不用烦躁每次打包压缩后还要部署多个服务器和环境，更开心的是每次家里写完代码，不用远程公司部署项目，提交代码后自动会为你部署。
> 本文基于.NET4.0的web项目和SVN的代码仓库以及Windows(其他系统平台大同小异)，简述Jenkins实现自动部署的配置。

## 名词解释

### 持续集成

> 持续集成(Continous Intergration):一个大项目是由多个模块组成的，每一个模块都有具体的小组负责开发，但有时候本模块独立测试正常，但与其他模块一起集成测试就会出问题。需要经常把所有模块集成在一起进行测试，尽早发现问题。关注点在于尽早发现项目整体运行问题，尽早解决。
 
### 持续部署

> 部署（deployment）还是发布（release）？部署一般指把应用或者服务“安装”到目标环境（开发、测试或者生产）中，而发布则应指把应用或者服务交付给最终用户使用。尽管这两个动作（尤其是在生产环境中）经常是同时发生的，但它们理应是两个完全不同的阶段。实际上一个好的持续交付流程恰恰应该把“部署”和“发布”解耦，变成两个可以独立控制的阶段。
> 部署的内容包括什么？无论是增量部署还是全量部署，都需要关注其部署的内容是什么，尤其是在广泛讨论微服务的今天。如果从部署角度看，我们把任何可以独立部署的内容称为一个“部署单元”。一个部署单元可以是一个模块，几个模块的联合体或者一个完整的应用，而如何划分则要视具体场景来定。一般来说，划分部署单元的最佳实践为一个可以独立演化、部署且和应用其他部分松耦合的集合。
> 全量部署（full）：全部文件重新拷贝并覆盖。优点稳定性好，但对带宽的要求大，更新时间长。
> 增量部署（min）：更新上个版本与最新版本之间的文件。优点速度快，对带宽的要求小，更新时间短，但若更新失败，则需要全量更新覆盖一次。
> 半增量部署（semi-increment）：只更新近期有更改的文件。保存一个时间范围内的更新文件，最长一个月，集合了全量部署与增量部署的优点。压缩包小，对带宽的要求小，更新时间短，容错率高，可以实现一个月内的增量更新。

### 持续交付

> 持续交付(Continous Delievery):用小版本不断进行快速迭代，不断收集用户反馈信息，用最快的速度改进优化。关注点在于研发团队的最新代码能够尽快让最终用户体验到。

### 自动化优点

1. 满足大型项目的需求：有时候开发人员在更新代码时在本地测试是正常的，但放在服务器上运行就会出问题。只有在生产环境下能正常跑起来的代码才算合格，关注点在于项目功能部署至服务器后可以运行。
2. 节约人力成本：开发人员以前每次都是手动复制文件到所有服务器进行更新替换操作，而且每次更新都要需要多次登录多台服务器，容易产生厌倦感。
3. 统一的版本控制：定期执行部署脚本，实现了单一源码统一部署，保证所实施的单位都是同一套代码的统一的版本。而且集成了自动为js文件和css文件创建hash值的功能，每次部署后都能自动更新cshtml文件引用js文件的版本信息，从而满足不清理浏览器缓存也能更新js文件的目的。
4. 部署速度快：每次仅对增量部分进行更新，无论是文件分发还是配置更新的内容都会更少，部署需要的时间也就相对较短。
5. 高安全性：部署时生成的更新包每次只会集成增量更新的文件，不会直接暴露系统的整套代码，避免代码泄露的风险。
6. 高稳定性：由于是使用脚本进行操作，脚本能自行判断是否需要更新，更新时不会重复执行更新脚本；而且使用脚本进行文件替换，操作快速而准确，避免了手工误覆盖造成的平台不稳定。部署时是并发部署，互不影响。
7. 代码检查：若代码有问题，则编译不成功，不会进行推送。增加了手动执行脚本回滚到上一个版本的功能。
8. 集成度高：使用统一的管理平台，把所有操作都写成一套脚本，方便修改。操作都封装好了，不熟悉的人只要按操作步骤执行构建命令即可自动进行部署。
9. 集成邮件通知：源码获取、编译、打包与部署分离；有完善的日志系统，可自动将每次编译打包的日志分发给提交代码的开发人员，并将简要的部署结果按事先编制的模板写入邮件正文；这样由于源码打包和部署是分离的，就明确了开发人员与运维人员的责任划分，开发人员只要关注是否能通过编译即可，运维人员在部署失败后会收到邮件，进行测试，并排查问题。

### 自动化缺点

1. 第一次需要手动先同步更新一次：无法完成初始化的部署操作，若已部署过的系统，但不知道部署时的版本号，只能先进行一次全量部署，而且若因为网络原因导致部署失败，则没有提示，需要人工操作进行判断。
2. 代码检查：无法满足所有的使用需求，因为有些代码虽然符合语法规范，可以正常编译，但里面的逻辑问题无法检测出来。所以增加了手动回滚到上一个版本的功能。